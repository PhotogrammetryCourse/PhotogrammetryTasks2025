// Убедитесь что название PR соответствует шаблону:
// Task01 <Имя> <Фамилия> <ВУЗ>

// Проверьте что обе ветки PR - task01 (отправляемая из вашего форкнутого репозитория и та в которую вы отправляете PR)

# Перечислите идеи и коротко обозначьте мысли которые у вас возникали по мере выполнения задания, в частности попробуйте ответить на вопросы:

1) Почему SIFT менее точно угадывает средний угол отклонения? изменяется ли ситуация если выкрутить параметр ORIENTATION_VOTES_PEAK_RATIO=0.999? почему?

__Ответ__: кажется, имеется в виду, что средний угол отклонения - это то направление, за которое проголосовали больше всего. И вот типо проблема в том, что таких направлений может быть несколько (точнее некоторые направлении могут быть сколько угодно близки по количеству голосов). В таком случае SIFT может создать две разных ключевых точки, которым присвоит эти вот два направления. А как раз параметр ORIENTATION_VOTES_PEAK_RATIO это порог, начиная с которого SIFT не отбросит направления с значением хотя бы ORIENTATION_VOTES_PEAK_RATIO*MAX_ORIENTATION. Если выкрутить его почти в 1, то всё, конечно, изменится, мы по сути запрещаем алгоритму создавать вторичные ключевые точки, а потому можем "неверно угадать средний угол отклонения", так как если значения bin-ов близки, это могло быть результатом погрешностей при вычислениях.


2) Как надежно замерить во сколько раз распараллеливание через OpenMP ускоряет ваш вариант SIFT? Попробуйте сделать это на вашем компьютере, какое ускорение относительно однопоточной версии оказалось? Сколько у вашего процессора ядер и сколько потоков?

__Ответ__: если нам позволяет время и мощности выбор любого гиперпараметра - это просто перебор гиперпараметра: изменили, запустили, замерили. Я запускал с флагами -fopenmp и без, ускорение примерно 6 раз.


3) Правда ли можно строить каждый слой в Gaussian пирамиде из самого первого слоя этой октавы? Или нужно обязательно делать так как предложено в статье - дополняя размытие предыдущего слоя этой октавы? Совпадают ли пирамиды визуально?

Я, честно сказать, не понял

4) Какие ожидания от картинок в Gaussian пирамиде можно придумать? Как проверить что работает корректно? С какой другой картинкой предыдущей октавы должна визуально совпадать конкретная картинка конкретной октавы? Как их визуально сравнить, ведь они разного размера?

__Ответ:__ Каждое следующее изображение в октаве должно быть более размытой версией предыдущего. Image(octave, layer+1) = blur(Image(octave, layer)). Можно еще вот такое сделать:
* Взять изображение из октавы k-1 
* Взять изображение из октавы k. Оно в 2 раза меньше
* Увеличьте в 2 раза до размера k-1-ой с помощью билинейной интерполяции
* Вычесть одно изображение из другого. Итог должен быть практически черным 


5) Почему в октаве Gaussian пирамиды s+3 картинки а не s+2 например?

__Ответ:__ Чтоб получить N слоев DoG, нужно N+1 слоев Гауссовой пирамиды (DoG_i = G_{i+1} - G_i).
Поэтому для s+2 DoG-слоев нам нужно s+3 Гауссовых слоев


7) Какие ожидания от картинок в DoG пирамиде можно придумать?

__Ответ:__ так, ну только визуальные всякие. Края объектов белые, при переходе к следующим слоям DoG мелкие детали исчезают, а более крупные структуры становятся заметнее, большие однородные области должны быть черными


8) Почему порог контрастности должен уменьшаться при увеличении числа слоев в октаве?

__Ответ:__ DoG = Gaussian(σ_{i+1}) - Gaussian(σ_i), когда σ_{i+1} ≈ σ_i, разница между размытыми изображениями становится меньше
Т.е. амплитуда отклика (контраст) в DoG для одной и той же особенности изображения уменьшается
Чтобы продолжать детектировать те же самые особенности при более высоком s, необходимо снизить порог контрастности
Или как вы сами объяснили в коде: // Порог уменьшается, т.к. при большем числе слоев разница между ними меньше, и отклик DoG ниже.
                                  


9) Какая строка ответственна за определение сигмы (или что почти то же самое - радиуса) которая задает окрестность по которой определяется ориентация ключевой точки?

Ключевая точка - экстремум в DoG, DoG - разности между слоями GaussianPyramid, которую мы строим здесь: 
```cpp
double sigma0 = INITIAL_IMG_SIGMA * pow(2.0, octave); // сигма первого слоя октавы
double sigmaCur = INITIAL_IMG_SIGMA * pow(2.0, octave) * pow(k, layer); // целевая сигма текущего слоя
double sigma = sqrt(sigmaCur * sigmaCur - sigma0 * sigma0); // сигма для размытия из первого слоя
```


9) За какой строки вашего кода дескриптор инвариантен к повороту картинки?

```cpp
// Матрица для поворота системы координат на угол, обратный основной ориентации точки
cv::Mat relativeShiftRotation = cv::getRotationMatrix2D(cv::Point2f(0.0f, 0.0f), -angle, 1.0);
// Поворачиваем вектор смещения в соответствии с ориентацией точки
cv::transform(shiftInVector, shiftInVector, relativeShiftRotation);
// Вычитаем основную ориентацию точки, чтобы ориентация градиента стала относительной.
// Это и обеспечивает инвариантность к повороту.
if (orientation < 0.0f) orientation += 360.0f;
orientation -= angle;
orientation = fmodf(orientation + 360.0f, 360.0f);
```


// Создайте PR.
// Дождитесь отработки Github Actions CI, после чего нажмите на зеленую галочку -> Details -> test_sift -> скопируйте весь лог тестирования.
// Откройте PR на редактирование (сверху справа три точки->Edit) и добавьте сюда скопированный лог тестирования внутри тега <pre> для сохранения форматирования и под спойлером для компактности и удобства:

<details><summary>Github Actions CI</summary><p>

<pre>
$ ./build/test_sift
Running main() from /home/runner/work/PhotogrammetryTasks2023/PhotogrammetryTasks2023/libs/3rdparty/libgtest/googletest/src/gtest_main.cc
[==========] Running 22 tests from 1 test suite.
[----------] Global test environment set-up.
[----------] 22 tests from SIFT
[ RUN      ] SIFT.MovedTheSameImage
[ORB_OCV] Points detected: 500 -> 500 (in 0.021269 sec)
...
[       OK ] SIFT.HerzJesu19RotateM40 (7730 ms)
[----------] 22 tests from SIFT (12918 ms total)
[----------] Global test environment tear-down
[==========] 22 tests from 1 test suite ran. (12918 ms total)
[  PASSED  ] 22 tests.
</pre>

</p></details>
